// Generated by CoffeeScript 1.6.1
(function() {
  var RESERVED_NAMES, async, buildPage, buildPages, buildScripts, buildStyles, eco, fs, helpers, link, log, markdown, mkdirs, path, read, stitch, stylus, util, watchPath, write, _, _verbosity,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  exports.version = "0.1.1";

  fs = require("fs");

  path = require("path");

  util = require("util");

  markdown = require("discount");

  eco = require("eco");

  stylus = require("stylus");

  stitch = require("stitch");

  _ = require("underscore");

  async = require("async");

  helpers = require("./helpers");

  _verbosity = 0;

  RESERVED_NAMES = ["images", "scripts", "styles", "plugins"];

  exports.skeleton = path.resolve(__dirname, "..", "example");

  exports.build = function(from, to, verbosity, watch) {
    var asyncPlugins, config, configFile, file, imageDest, paths, plugins, scriptBuilder, stylesBuilder, _fn, _i, _len, _ref;
    if (verbosity) {
      _verbosity = verbosity;
    }
    configFile = path.join(from, "config.json");
    config = {};
    if (fs.existsSync(configFile)) {
      config = JSON.parse(fs.readFileSync(configFile, "utf8"));
    }
    paths = {
      scripts: path.join(from, "scripts"),
      styles: path.join(from, "styles", "main.styl"),
      images: path.join(from, "images"),
      plugins: path.join(from, "plugins")
    };
    if (fs.existsSync(paths.scripts)) {
      scriptBuilder = function() {
        return buildScripts(paths.scripts, path.join(to, "scripts", "app.js"));
      };
      scriptBuilder();
      if (watch) {
        watchPath(paths.scripts, scriptBuilder);
      }
    }
    if (fs.existsSync(paths.styles)) {
      stylesBuilder = function() {
        return buildStyles(from, paths.styles, path.join(to, "styles", "main.css"));
      };
      stylesBuilder();
      if (watch) {
        watchPath(paths.styles, stylesBuilder);
      }
    }
    if (fs.existsSync(paths.images)) {
      imageDest = path.join(to, "images");
      mkdirs(imageDest);
      _ref = fs.readdirSync(paths.images);
      _fn = function(file) {
        return link(path.join(paths.images, file), path.join(imageDest, file));
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        _fn(file);
      }
    }
    if (fs.existsSync(paths.plugins)) {
      plugins = require(paths.plugins);
      if ('async' in plugins) {
        asyncPlugins = plugins.async;
        delete plugins.async;
      }
      _.extend(config, plugins);
    }
    if (asyncPlugins) {
      return async.parallel(asyncPlugins(config), function(err, results) {
        if (err) {
          console.error("Error running async plugins", err);
          return process.exit(1);
        } else {
          _.extend(config, results);
          return buildPages(config, from, to, watch);
        }
      });
    } else {
      return buildPages(config, from, to, watch);
    }
  };

  watchPath = function(path, callback) {
    log("Watching " + path + " for changes");
    return fs.watchFile(path, function(curr, prev) {
      if (curr.mtime > prev.mtime) {
        log("" + path + " has changed, rebuilding");
        return callback();
      }
    });
  };

  buildPages = function(config, from, to, watch) {
    var createNode, filenames, parseTitle, processPage, root, traverse;
    parseTitle = function(filename) {
      var id, re, slug, title, _ref;
      re = /^(?:(\d)+\s*(?:\.|-)\s*)?(?:@\((.*?)\)\s+)?(.*)/;
      _ref = filename.match(re).slice(1), id = _ref[0], slug = _ref[1], title = _ref[2];
      if (id) {
        id = parseInt(id, 10);
      }
      return [id, slug || helpers.slugify(title), title];
    };
    filenames = function(node) {
      if (node.type === "xml") {
        return "" + node.name + "." + node.type;
      } else {
        if (node.name === "index") {
          return {
            index: "index.html",
            content: "content.html"
          };
        } else {
          return {
            index: "" + node.name + "/index.html",
            content: "" + node.name + "/content.html"
          };
        }
      }
    };
    createNode = function(parent, file) {
      var extension, name, node, _ref;
      node = parent.files[file] = {};
      node.parent = parent;
      node.file = file;
      extension = path.extname(file);
      node.extension = extension.toLowerCase();
      node.filePath = path.join(parent.filePath, file);
      _ref = parseTitle(path.basename(file, extension)), node.id = _ref[0], node.name = _ref[1], node.title = _ref[2];
      name = node.name === "index" ? "" : node.name;
      node.path = path.join(parent.path, name);
      if (node.path === ".") {
        node.path = "";
      }
      return node;
    };
    processPage = function(filePath, node, options, currentDir) {
      var context, pageTemplate, parent, templates;
      parent = node.parent;
      templates = parent.templates ? [].concat(parent.templates) : [];
      pageTemplate = path.join(currentDir, "" + node.name + ".eco");
      if (fs.existsSync(pageTemplate)) {
        templates.push(pageTemplate);
        node.template = pageTemplate;
      }
      context = {};
      _.extend(context, node);
      _.extend(context, {
        basePath: from,
        outPath: to,
        root: options.root
      });
      _.extend(context, config);
      return buildPage({
        body: node.body,
        directory: path.join(options.outDir, parent.path),
        layout: options.layout,
        templates: templates,
        filename: filenames(node),
        context: context
      });
    };
    traverse = function(options, parent) {
      var currentDir, _ref, _ref1;
      if ((_ref = options.root) == null) {
        options.root = parent;
      }
      if ((_ref1 = options.layout) == null) {
        options.layout = path.join(options.baseDir, "layout.eco");
      }
      currentDir = path.join(options.baseDir, parent.filePath);
      return fs.readdir(currentDir, function(err, files) {
        var dirNames, file, filePath, node, page, pages, stat, _i, _j, _len, _len1, _ref2, _ref3, _ref4, _ref5, _results;
        if (err) {
          return util.error(err);
        }
        pages = {};
        dirNames = [];
        _ref2 = files.sort();
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          file = _ref2[_i];
          if (!(__indexOf.call(RESERVED_NAMES, file) < 0)) {
            continue;
          }
          if (file[0] === "." || file[file.length - 1] === "~") {
            log("Skipping " + file);
            continue;
          }
          filePath = path.join(currentDir, file);
          log("Processing " + filePath);
          if (watch) {
            watchPath(filePath, function() {
              return buildPages(config, from, to);
            });
          }
          node = createNode(parent, file);
          stat = fs.statSync(filePath);
          node.ctime = stat.ctime;
          node.mtime = stat.mtime;
          if (stat.isDirectory()) {
            node.type = "directory";
            node.files = {};
            dirNames.push(node);
          } else if (file === "template.eco") {
            if ((_ref3 = parent.templates) == null) {
              parent.templates = [];
            }
            parent.templates.push(filePath);
          } else if (file.match(/\.include\./)) {
            node.type = "include";
            if ((_ref4 = parent.includes) == null) {
              parent.includes = [];
            }
            parent.includes.push(file);
          } else if (node.extension === ".md") {
            node.type = file === "index.md" ? "index" : "page";
            node.body = markdown.parse(read(filePath));
            pages[filePath] = node;
          } else if (node.extension === ".html") {
            node.type = file === "index.html" ? "index" : "page";
            node.body = read(filePath);
            pages[filePath] = node;
          } else if (node.extension === ".xml") {
            node.type = "xml";
            node.body = read(filePath);
            pages[filePath] = node;
          } else if ((_ref5 = node.extension.toLowerCase()) === ".jpg" || _ref5 === ".png" || _ref5 === ".gif" || _ref5 === ".jpeg") {
            node.type = "image";
            pages[filePath] = node;
            link(filePath, path.join(options.outDir, parent.path, node.name + node.extension));
          } else if (node.extension === ".eco") {
            node.type = "template";
          } else {
            link(filePath, path.join(options.outDir, parent.path, file));
          }
        }
        for (page in pages) {
          node = pages[page];
          processPage(page, node, options, currentDir);
        }
        _results = [];
        for (_j = 0, _len1 = dirNames.length; _j < _len1; _j++) {
          node = dirNames[_j];
          node.templates = parent.templates;
          _results.push(traverse(options, node));
        }
        return _results;
      });
    };
    root = {
      name: "__root__",
      path: "",
      files: {}
    };
    return traverse({
      baseDir: from,
      outDir: to
    }, root);
  };

  buildPage = function(options) {
    var body, html, render;
    render = function(templates, body) {
      var context, remainingTemplates, template, _i;
      if (!templates.length) {
        return body;
      }
      context = {};
      _.extend(context, options.context);
      _.extend(context, helpers);
      context.dirs = helpers.nav(context.root);
      context.siblings = helpers.nav(context.parent);
      context.directory = options.directory;
      if (body != null) {
        context.body = body;
      }
      remainingTemplates = 2 <= templates.length ? __slice.call(templates, 0, _i = templates.length - 1) : (_i = 0, []), template = templates[_i++];
      return render(remainingTemplates, require(template)(context));
    };
    body = render(options.templates, options.body);
    if (fs.existsSync(options.layout)) {
      html = render([options.layout], body);
    } else {
      html = body;
    }
    if (options.filename instanceof Object) {
      return write(path.join(options.directory, options.filename.content), body, function(err) {
        if (err) {
          return util.error(err);
        }
        return write(path.join(options.directory, options.filename.index), html, function(err) {
          if (err) {
            return util.error(err);
          }
        });
      });
    } else {
      return write(path.join(options.directory, options.filename), body, function(err) {
        if (err) {
          return util.error(err);
        }
      });
    }
  };

  link = function(src, dst) {
    if (!fs.existsSync(dst)) {
      mkdirs(path.dirname(dst));
    }
    try {
      fs.linkSync(src, dst);
      return log("Linked from " + src + " to " + dst);
    } catch (e) {
      if (_verbosity || e.code !== 'EEXIST') {
        return console.error("Couldn't link " + src + " to " + dst + ":", e.message);
      }
    }
  };

  buildScripts = function(from, to) {
    var pkg;
    pkg = stitch.createPackage({
      paths: [from],
      compress: process.env.NODE_ENV === "production"
    });
    return pkg.compile(function(err, source) {
      if (err) {
        return util.error(err);
      }
      return write(to, source, function(err) {
        if (err) {
          return util.error(err);
        }
      });
    });
  };

  buildStyles = function(base, from, to) {
    return fs.readFile(from, "utf8", function(err, str) {
      if (err) {
        return util.error(err);
      }
      return stylus(str).set("filename", from).set("compress", process.env.NODE_ENV === "production").define("url", stylus.url({
        paths: [base]
      })).use(require("nib")())["import"]("nib").render(function(err, css) {
        if (err) {
          return util.error(err);
        }
        return write(to, css, function(err) {
          if (err) {
            return util.error(err);
          }
        });
      });
    });
  };

  read = function(file) {
    try {
      return fs.readFileSync(file, "utf8");
    } catch (e) {
      return util.error("Missing file: " + file);
    }
  };

  write = function(file, str, next) {
    if (str) {
      return fs.exists(file, function(exists) {
        if (!exists) {
          mkdirs(path.dirname(file));
        }
        log("Writing file " + file);
        return fs.writeFile(file, str.trim(), next);
      });
    }
  };

  mkdirs = function(pathName) {
    var base, dir, _i, _len, _ref, _results;
    base = "";
    _ref = pathName.split("/");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dir = _ref[_i];
      base += "" + dir + "/";
      if (!fs.existsSync(base)) {
        log("Creating directory " + base);
        _results.push(fs.mkdirSync(base, 0x1ed));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  log = function() {
    if (_verbosity) {
      return console.log.apply(null, arguments);
    }
  };

}).call(this);
